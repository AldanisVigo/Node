/*jshint node:true*/
/*global require, it:true, describe:true*/
"use strict";
var assert = require('assert');
var Yav = require('./yav');

describe('Yav', function() {

  describe('custom validation', function() {
    it('should be able to conditionally add errors to the validator', function(complete) {
      var val = new Yav();
      val.validateCustom(function(validator, done) {
        if (validator.get('field1') !== validator.get('field2')){
          validator.addGlobalError('field1 must equal field2');
        }
        done();
      });

      val.bind({ field1: 1, field2: 2 });
      val.validate(function() {
        assert(val.globalErrors().length > 0);

        val.bind({ field1: 1, field2: 1 });
        val.validate(function() {
          assert(val.globalErrors().length === 0);
          complete();
        });
      });

    });
  });

  describe('presence validation', function() {

    it('should cause an error on blank values', function(done) {
      var val = new Yav();
      val.validatePresence('field1');
      val.validate(function() {
        assert(val.errors().field1);
        assert(val.globalErrors().length === 0);
        done();
      });
    });

    it('should return a customized error message when the message option is passed', function(done) {
      var val = new Yav();
      val.validatePresence('field1', { message: 'ZZZ ERR' });
      val.validate(function() {
        assert(val.errors().field1[0] === 'ZZZ ERR');
        done();
      });
    });

    it('should not cause an error for non blank values', function(done) {
      var val = new Yav();
      val.validatePresence('field1');
      val.set('field1', 'blah');
      val.validate(function() {
        assert(!val.errors().field1);
        done();
      });
    });

  });

  describe('length validation', function() {

    it('should cause an error with strings that are too long', function(done) {
      var val = new Yav();
      val.validateLength('field1', { max: 3 });
      val.validateLength('field2', { max: 3 });
      val.set('field1', '123');
      val.set('field2', '1234');
      val.validate(function(){
        assert(!val.errors().field1);
        assert(val.errors().field2);
      });
      done();
    });

    it('should cause an error with strings that are too short', function(done) {
      var val = new Yav();
      val.validateLength('field1', { min: 4 });
      val.validateLength('field2', { min: 4 });
      val.set('field1', '123');
      val.set('field2', '1234');
      val.validate(function(){
        assert(val.errors().field1);
        assert(!val.errors().field2);
      });
      done();
    });

  });

  describe('numericality validation', function() {

    it('should cause an error with non-numeric values', function(done) {
      var val = new Yav();
      val.validateNumericality('field1');
      val.validateNumericality('field2');
      val.set('field1', 'deadbeef');
      val.set('field2', '1a');
      val.validate(function() {
        assert(val.errors().field1);
        assert(val.errors().field2);
        done();
      });
    });

    it('should not cause an error with numeric values', function(done) {
      var val = new Yav();
      val.validateNumericality('field1');
      val.validateNumericality('field2');
      val.validateNumericality('field3');
      val.validateNumericality('field4');
      val.validateNumericality('field5');
      val.validateNumericality('field6');
      val.set('field1', '1');
      val.set('field2', '-1');
      val.set('field3', '-1.0');
      val.set('field4', '-.01');
      val.set('field5', '-1.01e5');
      val.set('field6', '-.01E6');
      val.validate(function() {
        assert(!val.errors().field1);
        assert(!val.errors().field2);
        assert(!val.errors().field3);
        assert(!val.errors().field4);
        assert(!val.errors().field5);
        assert(!val.errors().field6);
        done();
      });
    });

    it('should validate option "integer"', function(done) {
      var val = new Yav();
      val.validateNumericality('field1', {integer:true});
      val.validateNumericality('field2', {integer:true});
      val.validateNumericality('field3', {integer:true});
      val.set('field1', '1');
      val.set('field2', '1.0');
      val.set('field3', '1e3');
      val.validate(function() {
        assert(!val.errors().field1);
        assert(val.errors().field2);
        assert(!val.errors().field3);
        done();
      });
    });

    it('should validate option "greaterThan"', function(done) {
      var val = new Yav();
      val.validateNumericality('field1', {greaterThan: 3});
      val.validateNumericality('field2', {greaterThan: 3});
      val.validateNumericality('field3', {greaterThan: 3});
      val.set('field1', 2);
      val.set('field2', 3);
      val.set('field3', 3.1);
      val.validate(function() {
        assert(val.errors().field1);
        assert(val.errors().field2);
        assert(!val.errors().field3);
        done();
      });
    });

    it('should validate option "greaterThanOrEqualTo"', function(done) {
      var val = new Yav();
      val.validateNumericality('field1', {greaterThanOrEqualTo: 3});
      val.validateNumericality('field2', {greaterThanOrEqualTo: 3});
      val.validateNumericality('field3', {greaterThanOrEqualTo: 3});
      val.set('field1', 2);
      val.set('field2', 3);
      val.set('field3', 3.1);
      val.validate(function() {
        assert(val.errors().field1);
        assert(!val.errors().field2);
        assert(!val.errors().field3);
        done();
      });
    });

    it('should validate option "lessThan"', function(done) {
      var val = new Yav();
      val.validateNumericality('field1', {lessThan: 3});
      val.validateNumericality('field2', {lessThan: 3});
      val.validateNumericality('field3', {lessThan: 3});
      val.set('field1', 2);
      val.set('field2', 3);
      val.set('field3', 3.1);
      val.validate(function() {
        assert(!val.errors().field1);
        assert(val.errors().field2);
        assert(val.errors().field3);
        done();
      });
    });

    it('should validate option "lessThanOrEqualTo"', function(done) {
      var val = new Yav();
      val.validateNumericality('field1', {lessThanOrEqualTo: 3});
      val.validateNumericality('field2', {lessThanOrEqualTo: 3});
      val.validateNumericality('field3', {lessThanOrEqualTo: 3});
      val.set('field1', 2);
      val.set('field2', 3);
      val.set('field3', 3.1);
      val.validate(function() {
        assert(!val.errors().field1);
        assert(!val.errors().field2);
        assert(val.errors().field3);
        done();
      });
    });

  });

  describe('format validation', function() {
    it('should add an error for strings that do not match the regular expression', function(done) {
      var val = new Yav();
      val.validateFormat('field1', { 'with': /123/ });
      val.bind({field1: '1245'});
      val.validate(function() {
        assert(!!val.errors().field1);
        done();
      });
    });

    it('should not add an error for strings that do not match the regular expression', function(done) {
      var val = new Yav();
      val.validateFormat('field1', { 'with': /123/ });
      val.bind({field1: '12345'});
      val.validate(function() {
        assert(!val.errors().field1);
        done();
      });
    });
  });

  describe('inclusion validation', function() {
    it('should add an error when the field value is not in given values', function(done) {
      var val = new Yav();
      val.validateInclusion('field1', { 'in': ['1', '2', '3'] });
      val.bind({field1: '4'});
      val.validate(function() {
        assert(!!val.errors().field1);
        done();
      });
    });

    it('should not add an error when the field value is in given values', function(done) {
      var val = new Yav();
      val.validateInclusion('field1', { 'in': ['1', '2', '3'] });
      val.bind({field1: '2'});
      val.validate(function() {
        assert(!val.errors().field1);
        done();
      });
    });
  });

  describe('exclusion validation', function() {
    it('should not add an error when the field value is not in given values', function(done) {
      var val = new Yav();
      val.validateExclusion('field1', { 'in': ['1', '2', '3'] });
      val.bind({field1: '4'});
      val.validate(function() {
        assert(!val.errors().field1);
        done();
      });
    });

    it('should add an error when the field value is in given values', function(done) {
      var val = new Yav();
      val.validateExclusion('field1', { 'in': ['1', '2', '3'] });
      val.bind({field1: '2'});
      val.validate(function() {
        assert(!!val.errors().field1);
        done();
      });
    });
  });

  describe('method chainability', function() {
    it('should allow for certain methods (validations, bind, and validate) to chain together', function(done) {
      var val = new Yav();
      val.validateFormat('field1', { 'with': /123/ })
        .validatePresence('field2')
        .bind({field1: '1245'})
        .validate(function() {
          assert(!!val.errors().field1);
          assert(!!val.errors().field2);
          done();
        });
    });
  });

  describe('allow blank options', function() {
    it('should not add an error for strings that do not match the regular expression with allow blank option', function(done) {
      var val = new Yav();
      val.validateFormat('field1', { 'with': /123/, allowBlank: true });
      val.bind({field1: ''});
      val.validate(function(){
        assert(!val.errors().field1);
        done();
      });
    });

    it('should not add an error for strings that do not match the regular expression with allow blank option', function(done) {
      var val = new Yav();
      val.validateFormat('field1', { 'with': /123/, allowBlank: true });
      val.bind({field1: null});
      val.validate(function(){
        assert(!val.errors().field1);
        done();
      });
    });

    it('should not add an error for strings that do not match the regular expression with allow blank option', function(done) {
      var val = new Yav();
      val.validateFormat('field1', { 'with': /123/, allowBlank: true });
      val.bind({});
      val.validate(function(){
        assert(!val.errors().field1);
        done();
      });
    });
  });

  describe('an if or an unless option', function() {
    it('should skip a validation if the if function returns false', function(done) {
      var val = new Yav();
      val.validatePresence('field1', { 'if': function(v){ return v.get('field2') === 'skip'; } });
      val.bind({field1: '', field2: 'Xskip'});
      val.validate(function(){
        assert(!val.errors().field1);
        done();
      });
    });

    it('should not skip a validation if the if function returns true', function(done) {
      var val = new Yav();
      val.validatePresence('field1', { 'if': function(v){ return v.get('field2') === 'skip'; } });
      val.bind({field1: '', field2: 'skip'});
      val.validate(function() {
        assert(!!val.errors().field1);
        done();
      });
    });

    it('should skip a validation if the unless function returns true', function(done) {
      var val = new Yav();
      val.validatePresence('field1', { 'unless': function(v){ return v.get('field2') === 'skip'; } });
      val.bind({field1: '', field2: 'Xskip'});
      val.validate(function() {
        assert(!!val.errors().field1);
        done();
      });
    });

    it('should not skip a validation if the unless function returns false', function(done) {
      var val = new Yav();
      val.validatePresence('field1', { 'unless': function(v){ return v.get('field2') === 'skip'; } });
      val.bind({field1: '', field2: 'skip'});
      val.validate(function() {
        assert(!val.errors().field1);
        done();
      });
    });
  });

});
